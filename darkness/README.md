# C++の闇について

他の言語と比べて特別に深いかはわからないのだが、C++には闇がある。特に「処理系依存」と「未定義動作」まわりは闇が深い。

例えば、C++は「型」のサイズが決まっていない。実数型には、`float`、`double`、`long double`の三種類があり、`float`を単精度、`double`を倍精度と呼ぶことから、`double`は`float`の倍のサイズを持つと期待され、多くの実装ではそうなっている。

しかし、言語仕様としては、

```txt
float <= double <= long double
```

であることだけが規定されており、それぞれの実際のサイズは規定されていない。特に`long double`の実装は処理系依存であり、`double`と`long double`は同じサイズにとる処理系が多いが、x86系では`long double`は10バイトであるが、`sizeof(long double)`は16になる。つまり「16バイトを確保するが、実際に使うのは10バイト」である。

そもそも、C/C++では1バイトが何ビットであるかも決まっていない。多くの処理系では「1バイトは8ビット」であるが、言語仕様として決まっているのは「`char`のサイズが1バイト」であることだけで、`char`が何ビットであるかは決まっていない。

筆者は「`char`は1バイトで、1バイトは8ビット」とある記述に、わざわざ「`char`は8ビットとは限らない」などと指摘するような人を苦々しく思っているが、C++に闇があることは事実だし、闇は闇として知っておくのも悪くは無かろう。

以下ではC++の闇の例をいくつか紹介する。ただし、初学者はとりあえず気にしなくて良い。

## 処理系依存の動作について

C++には、処理系に依存する動作がある。言語として規定されていないが、処理系としては定義されている動作に「処理系定義の動作 (implementation-defined behavior)」がある。例えば[こんなもの](http://www.c-lang.org/detail/implementation_defined_behavior.html)が処理系に依存する。

処理系定義の動作でもっとも身近なのは、エラーメッセージだろう。

例えばこんなコードをコンパイルしてみよう。

```cpp
#include <cstdio>

int main() {
  int i = 0;
  int i = 1;
}
```

clang++の9.0.0では以下のようなエラーが出る。

```txt
prog.cc:5:7: error: redefinition of 'i'
  int i = 1;
      ^
prog.cc:4:7: note: previous definition is here
  int i = 0;
      ^
1 error generated.
```

g++の9.3.0ではこんなエラーになる。

```txt
prog.cc: In function 'int main()':
prog.cc:5:7: error: redeclaration of 'int i'
    5 |   int i = 1;
      |       ^
prog.cc:4:7: note: 'int i' previously declared here
    4 |   int i = 0;
      |       ^
```

同じGCCでも、g++の7.3.0はこんなエラーだ。

```txt
prog.cc: In function 'int main()':
prog.cc:5:7: error: redeclaration of 'int i'
   int i = 1;
       ^
prog.cc:4:7: note: 'int i' previously declared here
   int i = 0;
       ^
```

さて、正確には処理系定義動作ではなく(多分)未定義動作となるが、実質的には処理系に依存する動作の例として、`printf`のフォーマット文字列と引数の型の順番が整合していない場合が挙げられる。

`printf`は、最も良く使う関数だ。フォーマット文字列と呼ばれる文字列と、複数の変数を受け渡して、結果を出力する。例えば、整数は`%d`を指定する。

```cpp
printf("%d\n",3); // 3が表示される。
```

浮動小数点数なら`%f`だ。

```cpp
printf("%f\n",1.2); // 1.2が表示される。
```

また、複数の変数を指定することもできる。

```cpp
printf("%f %d\n",1.2, 3); // 1.2 3が表示される。
```

さて、問題は、フォーマット文字列の型と、引数の型の順番が整合していない場合だ。先の例のフォーマット文字列の順番を入れ替えて見る。

```cpp
printf("%d %f\n",1.2, 3); 
```

なんとなく、1.2を整数に丸め、3を浮動小数だと思って解釈し、「1 3」と表示されて欲しい気がする。しかし、実際には「3 1.2」と順番が入れ替わって表示される。

これには深淵な理由があるのだが、ここでは詳細は説明しない。詳しくは[Cの可変長引数とABIの奇妙な関係](https://qiita.com/qnighy/items/be04cfe57f8874121e76)という記事を参照して欲しい。


## 未定義動作について

仕様に定義されておらず、処理系でも定義されない動作を「未定義動作 (undefined behavior)」と呼ぶ。未定義動作は、結果が定義されていないため、結果として何が起きてもプログラマは文句を言うことができない。これを指して「鼻から悪魔」と呼ぶ。これは、動作が定義されていないのだから、プログラムを実行した結果、プログラマの鼻から悪魔が出てこようが文句は言えないよ、というジョークのようなものだ。

未定義動作は、例えば実行するたびに結果が異なったり、エラーでプログラムが止まったり、暴走したりする。特に最近困るのは、コンパイラが未定義動作を積極的に最適化に利用することだ。これを見てみよう。

C++は、関数が値を返す場合はその型を明示しなければならない。例えば整数を返す関数は、関数の名前の左側に返り値の型`int`を置く。

```cpp
int add(int a, int b){
  return a + b;
}
```

これは、整数を二つ受け取り、その和を返す関数だ。

さて、値を返すと宣言しながら、値を返さない関数を考える。例えばこんな関数だ。

```cpp
int func(void){
  print("Hello\n");
}
```

「整数を返す関数だよ」と宣言しているにも関わらず、return文が無い。実はこれは、未定義動作となる。

例えばこんなコードを考える。

```cpp
#include <cstdio>

int foo(void) {
  printf("foo\n");
}

void bar() {
  printf("bar\n");
  foo();
}

int main() {
  foo();
}
```

`main`関数は`foo`という関数を呼んでいるだけである。`foo`という関数は、整数を返すと定義されているにも関わらず`return`文が無い。また、`foo`の下には、このプログラムでは呼ばれない`bar`という関数がある。

このプログラムを、最適化無しでコンパイルすると、想定通り`foo`とだけ表示される。

```sh
$ g++ test.cpp
$ ./a.out
foo
```

しかし、GCC 8.0以上で、最適化オプション`-O1`以上をつけてコンパイル、実行すると、`foo`と`bar`を交互に、無数に表示して、最後はエラーで落ちる。

```sh
```